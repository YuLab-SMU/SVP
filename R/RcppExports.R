# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Extract the score of gene in each gene sets
#' @param x the score sparse matrix of gene for each gene sets.
#' @param rnm the row names of x matrix.
#' @param cnm the col names of x matrix.
#' @param g a list of gene set.
ExtractFeatureScoreCpp <- function(x, rnm, cnm, g) {
    .Call('_SVP_ExtractFeatureScoreCpp', PACKAGE = 'SVP', x, rnm, cnm, g)
}

CalRandSpatialKld <- function(coords, w, gx, gy, h, bg, random_times = 200L, seed = 1024L) {
    .Call('_SVP_CalRandSpatialKld', PACKAGE = 'SVP', coords, w, gx, gy, h, bg, random_times, seed)
}

#' Compute Background 2D Kernel Density
#' @param coords coordinate matrix.
#' @param gx Vector grid points in x direction, see(\code{seq(lims[1], lims[2], length.out=200)}).
#' @param gy Vector grid points in y direction, see(\code{seq(lims[3], lims[4], length.out=200)}).
#' @param h The vector of bandwidths for x and y directions, defaults to normal reference bandwidth
#' (see MASS::bandwidth.nrd), A scalar value will be taken to apply to both directions (see ks::hpi).
CalBgSpatialKld <- function(coords, gx, gy, h) {
    .Call('_SVP_CalBgSpatialKld', PACKAGE = 'SVP', coords, gx, gy, h)
}

#' Compute the Kullback–Leibler Divergence using 2D Kernel Density Estimation 
#' With Weighted and Statistical Test With Permutation for single weight vector.
#' @param coords coordinate matrix.
#' @param d the weight vector (the expression of gene or score of pathway).
#' @param bgkld the kernel density of background (the result of CalBgSpatialKld).
#' @param gx Vector grid points in x direction, see(\code{seq(lims[1], lims[2], length.out=100)}).
#' @param gy Vector grid points in y direction, see(\code{seq(lims[3], lims[4], length.out=100)}).
#' @param h The vector of bandwidths for x and y directions, defaults to normal reference bandwidth
#' (see bandwidth.nrd), A scalar value will be taken to apply to both directions (see ks::hpi).
#' @param random_times the permutation numbers for each weight to test whether 
#' it is significantly, default is 200.
#' @param seed The random seed to use to evaluate, default 123.
CalSpatialKld <- function(coords, d, bgkld, gx, gy, h, random_times = 200L, seed = 123L) {
    .Call('_SVP_CalSpatialKld', PACKAGE = 'SVP', coords, d, bgkld, gx, gy, h, random_times, seed)
}

#' Compute the Kullback–Leibler Divergence using 2D Kernel Density Estimation 
#' With Weighted And Statistical Test With Permutation.
#' @param coords coordinate matrix.
#' @param d matrix (the expression of gene or score of pathway).
#' @param l The limits of the rectangle covered by the grid as c(xl, xu, yl, yu).
#' @param h The vector of bandwidths for x and y directions, defaults to normal reference bandwidth
#' (see bandwidth.nrd), A scalar value will be taken to apply to both directions (see ks::hpi).
#' @param n the Number of grid points in each direction, default is 100.
#' @param random_times the permutation numbers for each weight to test whether
#' it is significantly, default is 200.
#' @param seed The random seed to use to evaluate, default 123.
CalSpatialKldCpp <- function(coords, d, l, h, n = 100L, random_times = 200L, seed = 123L) {
    .Call('_SVP_CalSpatialKldCpp', PACKAGE = 'SVP', coords, d, l, h, n, random_times, seed)
}

MCAStep1 <- function(X) {
    .Call('_SVP_MCAStep1', PACKAGE = 'SVP', X)
}

MCAStep2 <- function(Z, V, Dc) {
    .Call('_SVP_MCAStep2', PACKAGE = 'SVP', Z, V, Dc)
}

#' Computer the affinity score of all nodes in a graph to a seeds 
#' using Random Walk with Restart
#' @param x a adjacency matrix of a graph.
#' @param v a matrix define sets of starting seeds, each column 
#' corresponds to one set of seeds that a walker starts.
#' @param restart the restart probability used for RWR, it must be 
#' between 0 and 1, default is .75.
#' @param stop_delta minimum threshold to stop RWR, default is 1e-10.
#' @param stop_step step number to stop RWR, default is 50.
parallelCalRWR <- function(x, v, restart = 0.75, stop_delta = 1e-10, stop_step = 50L) {
    .Call('_SVP_parallelCalRWR', PACKAGE = 'SVP', x, v, restart, stop_delta, stop_step)
}

